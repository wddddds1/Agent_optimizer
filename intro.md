# HPC Agent Platform - Detailed Logic and Flow (MVP)

This document is a complete, implementation-level overview of how the current
platform works: control flow, agent responsibilities, data flow, gating, and
artifact layout. It is intended to be read alongside the codebase.

------------------------------------------------------------------------------
OVERVIEW
------------------------------------------------------------------------------

Goal
- Provide a local-only (macOS) optimization control plane that can:
  1) profile,
  2) classify,
  3) propose actions,
  4) apply and run,
  5) verify and record,
  6) iterate under a budget.

Key properties
- Deterministic orchestration; LLMs only propose actions or explanations.
- All side effects are executed by Skills (not LLMs).
- Every experiment produces auditable artifacts (patches, logs, metrics).
- Reproducible runs: same input yields same decision path unless randomized.

------------------------------------------------------------------------------
PROJECT STRUCTURE (CORE)
------------------------------------------------------------------------------

configs/
- action_space.yaml: fixed action catalog (run_config/build_config/source_patch).
- patch_families.yaml: patch families, risks, gates, and tags.
- direction_space.yaml: app-agnostic optimization directions.
- policy.yaml / candidate_policy.yaml / planner.yaml: hard rules and budgets.
- code_survey_guidance.yaml: structural rules for code survey suggestions.
- build_packs.yaml: build optimization packs (compiler flags).
- lammps_cases.yaml: case definitions.

orchestrator/
- graph.py: main state machine for optimization loop.
- main.py: CLI entry, resume, and session control.
- memory.py: in-memory experiment store.
- stop.py: budget and stopping rules.
- console.py: UI output.
- agents/: planner, optimizer, code survey, action synth, patch, etc.

skills/
- run/build/profile/verify/patch/report: only place where side effects happen.
- patch_git.py: worktrees and patch handling.
- metrics_parse.py: LAMMPS log parsing.

schemas/
- Pydantic IRs: JobIR, ActionIR, ExperimentIR, ProfileReport, ResultIR.

artifacts/
- sessions/<session_id>/runs/<run_id>/ (all run outputs and manifests).

------------------------------------------------------------------------------
HIGH-LEVEL PIPELINE
------------------------------------------------------------------------------

1) Baseline
- A baseline run is executed unless resume state indicates it should be skipped.
- Baseline provides timing + log parsing for later comparisons.

2) Profile + Features
- LAMMPS log parsing extracts timing breakdown.
- Profile features (compute/comm/neigh/output ratios) are computed.

3) Planning and Selection
- Planner decides which families to explore next and sets budgets.
- Optimizer selects candidates from:
  - fixed action_space.yaml (run_config/build_config/input_script),
  - generated source_patch actions from code survey + action synth.
- RouterRanker scores and ranks candidates.

4) Execute, Verify, Record
- Executor applies a single action in an isolated worktree.
- Run produces logs + metrics.
- Verifier applies gates: runtime, correctness, variance.
- Every run is stored as ExperimentIR with artifacts and patch diff.

5) Iterate
- Best chain is updated if improvement >= 0.1% and PASS.
- Loop continues until budgets or stop conditions trigger.

------------------------------------------------------------------------------
AGENTS AND ROLES
------------------------------------------------------------------------------

PlannerAgent
- Chooses which family/families to explore and candidate limits.
- Uses profile features, history, availability, and budgets.

OptimizerAgent
- Chooses specific candidates from the merged pool.
- Prefers evidence-aligned actions; exploration remains possible.

CodeSurveyAgent
- Scans code snippets for opportunities tied to patch_families.
- Uses structural evidence rules (see below).

ActionSynthAgent
- Converts opportunities into concrete ActionIR candidates.

CodePatchAgent
- Produces structured edits (not unified diff) against allowed files only.
- Edits are applied deterministically and diff is generated by git.

PatchDebugAgent
- Repairs patch proposals when preflight build fails.

VerifierAgent
- Applies gates (runtime, correctness, variance) with thresholds.

ReporterAgent
- Summarizes results and generates report.md/report_zh.md.

------------------------------------------------------------------------------
SOURCE_PATCH (STRUCTURAL) LOGIC
------------------------------------------------------------------------------

Two-phase source_patch generation:
1) CodeSurveyAgent
   - Consumes code_snippets with structural features:
     - loop_count, loop_signatures, adjacent_loop_signature
     - conditional_count, has_flag_condition
   - Only suggests a patch_family if structural conditions hold.

2) CodePatchAgent
   - Generates structured edits using anchors from code_snippets.
   - Enforces patch rules (allowed files, max lines, no forbidden patterns).
   - Applies only to actual backend files (OMP/OPT) when enabled.

Structural rules (current)
- loop_fusion: only when adjacent_loop_signature is true.
- loop_fission: only when has_flag_condition is true (diagnostic split).
- loop_interchange_blocking: requires loop_count >= 2.
- loop_unroll: requires loop_count >= 1.

Loop fission semantics (important)
- Only split optional/flag-guarded diagnostics, never move or duplicate core
  force updates. This avoids doubling hot work and preserves semantics.

Patch safety guards
- cache_local_pointers: must insert actual local caching lines.
- OMP backend (dbl3_t) rejects `double *xi = x[i]` style caching.
- If jtype-dependent caches are added, anchor must include `jtype = type[j]`.

NEED_MORE_CONTEXT handling
- If patch returns NEED_MORE_CONTEXT, snippets are expanded and retried.
- This prevents "no patch" stalls due to missing context.

------------------------------------------------------------------------------
BEST CHAIN LOGIC
------------------------------------------------------------------------------

Best chain (current best composite config)
- Tracks best_run_config + best_input_script + best_build_config + best_patch.
- Any new action is evaluated on the current best chain.
- If improvement >= 0.1% and PASS, it updates the best chain.
- Final composite run uses only the best chain, never unverified actions.

Resume behavior
- Resume loads best_chain experiment paths when available.
- If best_chain is loaded, baseline can be skipped for faster patch testing.

------------------------------------------------------------------------------
NEIGHBOR_TUNE (INPUT_SCRIPT) POLICY
------------------------------------------------------------------------------

Neighbor tuning is treated as a one-time batch scan:
- A single neighbor batch explores recommended candidates.
- Best PASS candidate is kept; neighbor_tune is then locked out for the session.
- Avoids repeated neighbor scans and keeps exploration bounded.

------------------------------------------------------------------------------
VERIFICATION / GATES
------------------------------------------------------------------------------

Runtime gate
- Non-zero exit or ERROR in log fails immediately.

Correctness gate
- For low-risk run_config: can be skipped (explicitly recorded).
- For input_script/source_patch/build_config: use baseline statistics.
- Drift thresholds derived from baseline runs (noise-aware).

Variance gate
- Applies CV threshold to repeated runs as configured.

------------------------------------------------------------------------------
ARTIFACTS AND AUDIT TRAIL
------------------------------------------------------------------------------

Each run has:
- experiment.json (ExperimentIR)
- manifest.json
- patch.diff (if source_patch)
- logs (stdout/stderr/log.lammps/time)
- metrics.json
- agent_trace.json (agent decisions + evidence)
- repro.sh (exact command/environment)

Session layout:
artifacts/sessions/<session_id>/
  runs/<run_id>/...
  report.md
  report_zh.md
  best_state.json

------------------------------------------------------------------------------
CLI ENTRYPOINTS
------------------------------------------------------------------------------

Typical run:
python -m orchestrator.main --case melt_xxlarge --max-iters 10 --max-runs 100

Common flags:
- --case <case_id>
- --max-iters / --max-runs / --max-wall-seconds
- --baseline-repeats
- --start-phase (RUN_TUNE / BUILD_TUNE / PATCH)
- --resume-state <best_state.json>
- --verbose-console (show raw logs if enabled)

------------------------------------------------------------------------------
CURRENT LIMITS AND NEXT STEPS
------------------------------------------------------------------------------

Known limitations
- Source_patch improvements are sensitive to correct backend targeting.
- Loop_fission is now restricted to diagnostic-only fission by design.
- Build_config / runtime improvements can dominate; patch gains are smaller.

Recommended future work
- Extend code_survey features (e.g., identify vectorization blockers).
- Improve patch feasibility scoring and reduce trivial patches.
- Extend resume best-chain loading across sessions more robustly.
- Add final "best-chain-only" report section with cumulative gains.

------------------------------------------------------------------------------
END
------------------------------------------------------------------------------
