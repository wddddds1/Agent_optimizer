app: lammps
# Application-specific mappings are implemented in skills/applications/lammps_app.py
patch_root: "third_party/lammps"
drift:
  drift_repair_max_attempts: 2
  thresholds:
    energy_drift_rel_max: 1.0e-4
    force_drift_rel_max: 1.0e-3
    temperature_cv_max: 0.05

patch_rules:
  allowed_globs:
    - "third_party/lammps/src/*.h"
    - "third_party/lammps/src/*.cpp"
    - "third_party/lammps/src/**/*.h"
    - "third_party/lammps/src/**/*.cpp"
  hotspot_globs:
    pair:
      - "third_party/lammps/src/pair_*.cpp"
      - "third_party/lammps/src/pair_*.h"
      - "third_party/lammps/src/pair_*_omp.cpp"
      - "third_party/lammps/src/pair_*_omp.h"
      - "third_party/lammps/src/OPENMP/pair_*_omp.cpp"
      - "third_party/lammps/src/OPENMP/pair_*_omp.h"
      - "third_party/lammps/src/OPT/pair_*_opt.cpp"
      - "third_party/lammps/src/OPT/pair_*_opt.h"
    neigh:
      - "third_party/lammps/src/neighbor*.cpp"
      - "third_party/lammps/src/neighbor*.h"
    comm:
      - "third_party/lammps/src/comm*.cpp"
      - "third_party/lammps/src/comm*.h"
    kspace:
      - "third_party/lammps/src/kspace*.cpp"
      - "third_party/lammps/src/kspace*.h"
    compute:
      - "third_party/lammps/src/compute*.cpp"
      - "third_party/lammps/src/compute*.h"
  scope_levels:
    hotspot:
      hotspot_only: true
      allowed_globs:
        - "third_party/lammps/src/pair_*.cpp"
        - "third_party/lammps/src/pair_*.h"
        - "third_party/lammps/src/OPENMP/pair_*_omp.cpp"
        - "third_party/lammps/src/OPENMP/pair_*_omp.h"
        - "third_party/lammps/src/OPT/pair_*_opt.cpp"
        - "third_party/lammps/src/OPT/pair_*_opt.h"
        - "third_party/lammps/src/neighbor*.cpp"
        - "third_party/lammps/src/neighbor*.h"
        - "third_party/lammps/src/comm*.cpp"
        - "third_party/lammps/src/comm*.h"
        - "third_party/lammps/src/compute*.cpp"
        - "third_party/lammps/src/compute*.h"
        - "third_party/lammps/src/kspace*.cpp"
        - "third_party/lammps/src/kspace*.h"
    module:
      allowed_globs:
        - "third_party/lammps/src/pair*.cpp"
        - "third_party/lammps/src/pair*.h"
        - "third_party/lammps/src/neighbor*.cpp"
        - "third_party/lammps/src/neighbor*.h"
        - "third_party/lammps/src/npair*.cpp"
        - "third_party/lammps/src/npair*.h"
        - "third_party/lammps/src/comm*.cpp"
        - "third_party/lammps/src/comm*.h"
        - "third_party/lammps/src/compute*.cpp"
        - "third_party/lammps/src/compute*.h"
        - "third_party/lammps/src/kspace*.cpp"
        - "third_party/lammps/src/kspace*.h"
        - "third_party/lammps/src/OPENMP/*.cpp"
        - "third_party/lammps/src/OPENMP/*.h"
        - "third_party/lammps/src/OPT/*.cpp"
        - "third_party/lammps/src/OPT/*.h"
    global:
      allowed_globs:
        - "third_party/lammps/src/*.h"
        - "third_party/lammps/src/*.cpp"
        - "third_party/lammps/src/**/*.h"
        - "third_party/lammps/src/**/*.cpp"
  forbidden_patterns:
    - "\\bMPI_Abort\\b"
    - "\\bMPI_Finalize\\b"
    - "\\bexit\\s*\\("
  max_lines_changed: 1000
  max_files_changed: 10
  max_context_chars: 120000
  max_snippets: 12
  debug_max_attempts: 2
  runtime_crash_debug_max_attempts: 3

patch_families:
  - id: param_table_pack
    description: "Pack multiple coefficient arrays (cutsq, lj1-lj4, offset) into a single cache-aligned struct for one-cache-line lookup per type pair. Reference: pair_lj_cut_opt.cpp fast_alpha_t."
    transform_types: ["param_table_pack"]
    requires_caps: ["memory_tuning_knobs"]
    requires_hotspot: ["pair"]
    risk: "medium"
    mandatory_gates: ["runtime", "correctness", "variance"]
    patch_tags: ["mem_locality", "compute_opt", "algorithm"]
    reference_file: "third_party/lammps/src/OPT/pair_lj_cut_opt.cpp"
    detection_hints:
      patterns:
        - "multiple coefficient arrays (cutsq, lj1-lj4, offset) loaded separately per type pair"
        - "struct-of-arrays coefficient layout causing multiple cache line loads"
      languages: ["cpp"]
      indicators:
        - "multiple movsd from different base addresses per neighbor iteration"
  - id: special_pair_split
    description: "Split sbindex==0 fast path from special-bond handling. ~99% of pairs skip factor_lj and NEIGHMASK. Reference: pair_lj_cut_opt.cpp lines 123-192."
    transform_types: ["special_pair_split"]
    requires_caps: ["source_patch"]
    requires_hotspot: ["pair"]
    risk: "medium"
    mandatory_gates: ["runtime", "correctness", "variance"]
    patch_tags: ["compute_opt", "algorithm"]
    reference_file: "third_party/lammps/src/OPT/pair_lj_cut_opt.cpp"
    detection_hints:
      patterns:
        - "sbmask/NEIGHMASK check on every neighbor when >99% are zero"
        - "factor_lj = special_lj[sbmask(j)] branch in inner loop"
      languages: ["cpp"]
      indicators:
        - "branch in inner loop that is almost always not-taken"
  - id: flat_coeff_lookup
    description: "Flatten 2D coefficient arrays cutsq[i][j] into 1D tabsix[i*ntypes+j] to eliminate pointer indirection. Usually combined with param_table_pack."
    transform_types: ["flat_coeff_lookup"]
    requires_caps: ["memory_tuning_knobs"]
    requires_hotspot: ["pair"]
    risk: "medium"
    mandatory_gates: ["runtime", "correctness", "variance"]
    patch_tags: ["mem_locality", "algorithm"]
    reference_file: "third_party/lammps/src/OPT/pair_lj_cut_opt.cpp"
    detection_hints:
      patterns:
        - "2D array indexing cutsq[itype][jtype] with pointer-to-pointer indirection"
        - "double** coefficient lookup in inner loop"
      languages: ["cpp"]
      indicators:
        - "pointer chase visible in assembly for coefficient access"
  - id: neighbor_prefetch
    description: "Insert software prefetch for next neighbor's coordinates in inner loop: __builtin_prefetch(&x[jlist[jj+dist]])."
    transform_types: ["neighbor_prefetch"]
    requires_caps: ["memory_tuning_knobs"]
    requires_hotspot: ["pair"]
    risk: "low"
    mandatory_gates: ["runtime", "correctness", "variance"]
    patch_tags: ["mem_locality"]
    profiling_trigger: ["memory_bound", "cache_thrashing"]
    detection_hints:
      patterns:
        - "indirect neighbor coordinate access x[jlist[jj]] without prefetch"
        - "inner loop iterates over neighbor list with random access to coordinate array"
      languages: ["cpp"]
      indicators:
        - "high L1/L2 cache miss rate on coordinate loads in pair force loop"

domain_knowledge:
  application_type: "molecular dynamics"
  kernel_semantics:
    - name: "pair_compute"
      description: "Newton's third law pairwise force computation, dominates runtime"
      known_optimizations:
        - "AoS to SoA data layout for better vectorization"
        - "neighbor list binning strategy affects cache performance"
        - "half vs full neighbor list trade-off"
        - "coefficient struct packing for single cache-line lookup"
    - name: "neighbor_build"
      description: "Verlet neighbor list construction"
      known_optimizations:
        - "bin size tuning (skin distance)"
        - "multi-threaded neighbor build"
        - "stencil-based neighbor finding"
    - name: "comm"
      description: "MPI communication for ghost atom exchange"
      known_optimizations:
        - "communication buffer packing optimization"
        - "overlap communication with computation"
    - name: "kspace"
      description: "Long-range Coulombic solver (PPPM/Ewald)"
      known_optimizations:
        - "FFT grid tuning"
        - "real-space vs k-space cutoff balance"
  common_pitfalls:
    - "Manual loop unrolling hurts compiler auto-vectorization"
    - "Adding #pragma omp simd can conflict with existing OMP threading"
    - "Changing neighbor list data structures without updating ghost comm"
    - "Breaking Newton third law symmetry in pair force computation"
  effective_strategies:
    - category: "data_layout"
      description: "Convert coefficient arrays from AoS to SoA or pack into cache-aligned struct"
      typical_gain: "15-40%"
    - category: "memory_path"
      description: "Local pointer caching for neighbor list traversal, software prefetch"
      typical_gain: "5-15%"
    - category: "branch_elimination"
      description: "Split sbindex==0 fast path from special-bond handling in inner loop"
      typical_gain: "5-20%"
    - category: "vectorization"
      description: "Ensure inner force loop is auto-vectorizable via restrict, alignment, SoA"
      typical_gain: "10-30%"

variants_prefer_mode: exclusive
variants:
  - id: "openmp_backend"
    when:
      run_args_contains:
        - "-sf omp"
        - "-suffix omp"
        - "-pk omp"
    prefer_globs:
      - "third_party/lammps/src/OPENMP/pair_*_omp.cpp"
      - "third_party/lammps/src/OPENMP/pair_*_omp.h"
      - "third_party/lammps/src/pair_*_omp.cpp"
      - "third_party/lammps/src/pair_*_omp.h"
  - id: "opt_backend"
    when:
      run_args_contains:
        - "-sf opt"
        - "-suffix opt"
    prefer_globs:
      - "third_party/lammps/src/OPT/pair_*_opt.cpp"
      - "third_party/lammps/src/OPT/pair_*_opt.h"
